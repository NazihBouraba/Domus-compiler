// Specification JCup
import java.util.HashMap; 
import java_cup.runtime.*;
import java.lang.*;

parser code {:
	public static void main(String args[]) throws Exception {
		new parser(new Yylex(System.in)).parse();
	}

	public void syntax_error(Symbol cur_token) { 
		// n'interrompt pas la compil... 
		// on est par defaut dans l'etat error qui permet ensuite la recup
		// par défaut : report_error("syntax error", null);
		report_error("Syntaxe incorrecte <"+tokenToString(cur_token)+">", null);        
	}

	public void report_error(String message, Object info) {   
		// n'interrompt pas la compil
		if (info == null) System.err.println("Mon erreur <"+ ptext()+ "> ligne "+ pline() + ", colonne " + pcolumn() + " : " + message);
		else System.err.println("Mon erreur <"+ptext()+ "> ligne "+ pline() + ", colonne " + pcolumn() + " : " +message+" : "+info);
		System.err.println("-> mais on continue l'analyse... ");
	}

	public void unrecovered_syntax_error(Symbol cur_token) {
    	// par defaut : report_fatal_error("Couldn't repair and continue parse", null);
		// on n'a pas reussi a faire de la recup
		report_fatal_error("Recuperation impossible <"+tokenToString(cur_token)+">", null);   // interrompt la compil     
	}

	public void report_fatal_error(String message, Object info) {  
		// qd cette fct est appelee, message vaut par defaut "Couldn't repair and continue parse"
		String m = "Mon erreur fatale <"+ ptext()+ "> ligne " + pline() + ", colonne " + pcolumn() + " : " + message;
		if (info == null) System.err.println(m);
		else System.err.println(m+" : "+info);
		System.err.println("-> arrêt de l'analyse...");
		done_parsing(); // interrompt la compil
  	}

	public int pline(){
		return ((Yylex)getScanner()).getYyLine();
	}
	public int pcolumn(){
		return ((Yylex)getScanner()).getYyColumn();
	}
	public String ptext(){
		return ((Yylex)getScanner()).getYyText();
	}

	public String tokenToString (Symbol token) {
// qqs exemples pour voir...
   //  switch (token.sym) {
//	case sym.SI : return "SI"; 
//	case sym.CHAINE : return "CHAINE "+token.value;  
//	case sym.ENTIER : return "ENTIER "+token.value;  
	//  ... A compléter !!
	return "Token imprévu ou error";
	//}
}



:}
action code {:




:}

non terminal S; // axiome

non terminal da; // declaration appareils
non terminal dad; // declaration appareils detaillé

non terminal ds; // declaration des scenarios
non terminal dsd; // declaration scenarios detaillés
non terminal scenario; // genere un scenario

non terminal MOT; // mot pour generer des nom,nom,nom,nom
non terminal x; // genere soit appareil ou nom
non terminal sinon; // genere le blok sinon apres si

non terminal di;
non terminal dc; // declaration commandes 
non terminal dat;
non terminal w;
non terminal did,dcd;
non terminal mesgouact;
non terminal msgs;
non terminal msg;










terminal String ACTION; // allumer eteindre ....
terminal String DATE;

terminal String PDO; // debut programme domus
terminal String PDF; // fin programme domus

terminal String COTE;

terminal String DAO; // debut declaration appareil
terminal String DAF; // fin declaration appareil

terminal String DIO; // debut declaration interface
terminal String DIF; // fin declaration interface

terminal String DSO; // debut declaration scenario
terminal String DSF; // fin declaration scenario

terminal String DCO; // debut declaration commande
terminal String DCF; // fin declaration commande


terminal String DSCO; // debut declaration d'un scenario
terminal String DSCF; // fin declaration d'un scenario

terminal String VG; //","
terminal String PT; // "."
terminal String nom; // chaine de caractere
terminal String APPAREIL; // autreappareil(cafe)
terminal String AO; // "{"
terminal String AF; // "}"
terminal String PO; // "("
terminal String PF; // ")"
terminal String EGAL; // "="
terminal String DEGAL; // "=="
terminal String DP; // ":"
terminal String PV; // ";"
terminal String H; // "double cotte"
terminal String ETAT; // .allumé ..
terminal String MSG; // MESSGE("VGFDGDFGFDG")
terminal String CHAINE; // "VGFDGDFGFDG"
terminal String APPAREIL_TYPE; // eclairage volet
terminal String AUTRE_APPAREIL; // autre_appareil(cafe)
terminal String DEFINIR; // definir
terminal String INTERFACE_TYPE ; // interrupteur
terminal String ASSOCIER ; // associer
terminal String PROGRAMMER ; // associer
terminal String cm ; // message
terminal String SI ; // si
terminal String MESSAGE ; // message
terminal String SINON ; // sinon
terminal String POURTOUT ; // pourtout
terminal String FAIT ; // fait
terminal String FAIRE ; // faire
terminal String ETATS ; // ETATS
terminal String FSI ; // fsi
terminal String EXECUTER_SCENARIO; // fsi
terminal String ALORS ; // fsi









//axiome
S ::= PDO da di ds dc PDF  {:System.out.println("analyse terminée"); :};


//declaration des appareils
da ::= DAO dad DAF  ;

dad::= APPAREIL_TYPE MOT PT  dad   // eclairage e1,e2,,,, .

|  AUTRE_APPAREIL MOT  PT dad  // autreappareil(cafeteria) cafe .

| DEFINIR nom EGAL AO MOT AF PT dad // definir mon eclairage_salon = {e1,e2}

|  ; //sortir





// declaration des scenarios

ds ::= DSO dsd DSF  ;

dsd ::= DSCO scenario DSCF dsd // declaration plusieurs scenarios

| ;  

scenario ::= POURTOUT nom DP x FAIRE   scenario  FAIT PV scenario   // pourtout v:volet faire v.ouvrir ; fait;

| nom PT ACTION PV scenario // e1.allumer 

| EXECUTER_SCENARIO nom PV scenario// executer_scenario soirée;

| SI PO nom PT ETAT DEGAL ETATS PF ALORS scenario  sinon  FSI PV  scenario //si(rad1.etat == eteint) alors rad1.allumer;fsi; ou sinon ...

| msgs PV  scenario// afficher un message 


|;

sinon ::= SINON scenario   | ; // 
x ::= nom | APPAREIL_TYPE | AUTRE_APPAREIL ;


//<DECLARATION_INTERFACES>

di ::= DIO did DIF  ;  
did ::= INTERFACE_TYPE MOT PT did | ; // interrupteur b1, b2.


//<DECLARATION_COMMANDES>
dc::= DCO dcd DCF ;

dcd ::= ASSOCIER nom EGAL nom PT dcd 

| ASSOCIER nom EGAL AO MOT AF PT  dcd 

|PROGRAMMER nom EGAL AO dat AF PT dcd 

|PROGRAMMER nom EGAL DATE PT dcd 

| ;



dat ::= DATE VG dat | DATE;

mesgouact ::= nom PT ACTION | msgs |mesgouact PV  nom PT ACTION  | mesgouact PV  msgs   ;

MOT ::= nom VG MOT| nom ;





msgs ::= MESSAGE PO msg PF ;

msg ::= nom VG msg |cm VG msg | nom | cm | nom PT ETAT msg | nom PT ETAT;




